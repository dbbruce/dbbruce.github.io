<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>003-requests相关知识 | 董勉 | 技术博客 | 成功的秘诀在于耐心和求胜心.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
    <meta name="description" content="桑弧蓬矢">
  
  
  
    <link rel="alternate" href="/atom.xml" title="董勉 | 技术博客 | 成功的秘诀在于耐心和求胜心." type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">董勉 | 技术博客 | 成功的秘诀在于耐心和求胜心.</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">此生当克己勤免，自强不息 .</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> 首页</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> 归档</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> 关于</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-爬虫/基础/003-requests相关知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      003-requests相关知识
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-08-11T04:04:52.000Z" itemprop="datePublished">2023年08月11日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/%E7%88%AC%E8%99%AB%E7%B1%BB/">爬虫类</a> > <a class="article-category-link" href="/categories/%E7%88%AC%E8%99%AB%E7%B1%BB/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

      
        <span class="article-views">
  <i class="fa fa-views"></i>
  <i id="busuanzi_container_page_pv">
      <i id="busuanzi_value_page_pv"></i>
  </i>
</span>

      
      
<a href="/2023/08/11/%E7%88%AC%E8%99%AB/%E5%9F%BA%E7%A1%80/003-requests%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/#comments" class="article-comment-link">
  
    
    
    
    
    
  
<!--   <i class="fa fa-commt"></i> -->
<!--   留言 -->
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">&#x27;https://api.github.com/events&#x27;</span>)</span><br><span class="line">r = requests.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>, data = &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line">r = requests.put(<span class="string">&#x27;http://httpbin.org/put&#x27;</span>, data = &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line">r = requests.delete(<span class="string">&#x27;http://httpbin.org/delete&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r = requests.head(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="comment"># 获得报文首部</span></span><br><span class="line"><span class="comment"># HEAD方法和GET方法一样，知识不返回豹纹的主体部分，用于确认URI的有效性及资源更新的日期时间等。</span></span><br><span class="line"><span class="comment"># 具体来说：1、判断类型； 2、查看响应中的状态码，看对象是否存在（响应：请求执行成功了，但无数据返回）； 3、测试资源是否被修改过</span></span><br><span class="line"><span class="comment"># HEAD方法和GET方法的区别： GET方法有实体，HEAD方法无实体。</span></span><br><span class="line"></span><br><span class="line">r = requests.options(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)  <span class="comment"># 询问支持的方法</span></span><br><span class="line"><span class="comment"># OPTIONS方法用来查询针对请求URI指定资源支持的方法（客户端询问服务器可以提交哪些请求方法）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h4 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.text</span><br></pre></td></tr></table></figure>
<p>Requests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。</p>
<p>请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用 r.encoding 属性来改变它：</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.encoding</span><br><span class="line"><span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">r.encoding = <span class="string">&#x27;ISO-8859-1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果你改变了编码，每当你访问 r.text ，Request 都将会使用 r.encoding 的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了。<br>在你需要的情况下，Requests 也可以使用定制的编码。如果你创建了自己的编码，并使用 codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由 Requests 来为你处理编码。</p>
<h4 id="二进制响应内容"><a href="#二进制响应内容" class="headerlink" title="二进制响应内容"></a>二进制响应内容</h4><p>你也能以字节的方式访问请求响应体，对于非文本请求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.content </span><br></pre></td></tr></table></figure>
<p>Requests 会自动为你解码 gzip 和 deflate 传输编码的响应数据。</p>
<p>例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">i = Image.<span class="built_in">open</span>(BytesIO(r.content))</span><br></pre></td></tr></table></figure>

<h4 id="JSON-响应内容"><a href="#JSON-响应内容" class="headerlink" title="JSON 响应内容"></a>JSON 响应内容</h4><p>Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">&#x27;https://api.github.com/events&#x27;</span>)</span><br><span class="line">r.json()</span><br></pre></td></tr></table></figure>
<p>如果 JSON 解码失败， r.json() 就会抛出一个异常。例如，响应内容是 401 (Unauthorized)，尝试访问 r.json() 将会抛出 ValueError: No JSON object could be decoded 异常。<br>需要注意的是，成功调用 r.json() 并<strong>不</strong>意味着响应的成功。有的服务器会在失败的响应中包含一个 JSON 对象（比如 HTTP 500 的错误细节）。这种 JSON 会被解码返回。要检查请求是否成功，请使用 r.raise_for_status() 或者检查 r.status_code 是否和你的期望相同。</p>
<h4 id="原始响应内容"><a href="#原始响应内容" class="headerlink" title="原始响应内容"></a>原始响应内容</h4><p>在罕见的情况下，你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw。 如果你确实想这么干，那请你确保在初始请求中设置了 stream&#x3D;True。具体你可以这么做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">&#x27;https://api.github.com/events&#x27;</span>, stream=<span class="literal">True</span>)</span><br><span class="line">r.raw</span><br><span class="line">&gt;&lt;requests.packages.urllib3.response.HTTPResponse <span class="built_in">object</span> at <span class="number">0x101194810</span>&gt;</span><br><span class="line">r.raw.read(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h4 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://api.github.com/some/endpoint&#x27;</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;my-app/0.0.1&#x27;</span>&#125;</span><br><span class="line">r = requests.get(url, headers=headers)</span><br></pre></td></tr></table></figure>
<p>如果在 .netrc 中设置了用户认证信息，使用 headers&#x3D; 设置的授权就不会生效。而如果设置了 auth&#x3D; 参数，<code>.netrc</code> 的设置就无效了。<br>如果被重定向到别的主机，授权 header 就会被删除。<br>代理授权 header 会被 URL 中提供的代理身份覆盖掉。<br>在我们能判断内容长度的情况下，header 的 Content-Length 会被改写。</p>
<h4 id="POST一个多部分编码-Multipart-Encoded-的文件"><a href="#POST一个多部分编码-Multipart-Encoded-的文件" class="headerlink" title="POST一个多部分编码(Multipart-Encoded)的文件"></a>POST一个多部分编码(Multipart-Encoded)的文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;report.xls&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line">r = requests.post(url, files=files)</span><br><span class="line">r.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: (<span class="string">&#x27;report.xls&#x27;</span>, <span class="built_in">open</span>(<span class="string">&#x27;report.xls&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>), <span class="string">&#x27;application/vnd.ms-excel&#x27;</span>, &#123;<span class="string">&#x27;Expires&#x27;</span>: <span class="string">&#x27;0&#x27;</span>&#125;)&#125;</span><br><span class="line">r = requests.post(url, files=files)</span><br><span class="line">r.text</span><br></pre></td></tr></table></figure>

<h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br><span class="line">r.status_code</span><br></pre></td></tr></table></figure>


<h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.headers</span><br></pre></td></tr></table></figure>

<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://example.com/some/cookie/setting/url&#x27;</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">r.cookies[<span class="string">&#x27;example_cookie_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line">要想发送你的cookies到服务器，可以使用 cookies 参数：</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/cookies&#x27;</span></span><br><span class="line">cookies = <span class="built_in">dict</span>(cookies_are=<span class="string">&#x27;working&#x27;</span>)</span><br><span class="line">r = requests.get(url, cookies=cookies)</span><br><span class="line">r.text</span><br><span class="line"></span><br><span class="line">Cookie 的返回对象为 RequestsCookieJar，它的行为和字典类似，但接口更为完整，适合跨域名跨路径使用。你还可以把 Cookie Jar 传到 Requests 中：</span><br><span class="line">jar = requests.cookies.RequestsCookieJar()</span><br><span class="line">jar.<span class="built_in">set</span>(<span class="string">&#x27;tasty_cookie&#x27;</span>, <span class="string">&#x27;yum&#x27;</span>, domain=<span class="string">&#x27;httpbin.org&#x27;</span>, path=<span class="string">&#x27;/cookies&#x27;</span>)</span><br><span class="line">jar.<span class="built_in">set</span>(<span class="string">&#x27;gross_cookie&#x27;</span>, <span class="string">&#x27;blech&#x27;</span>, domain=<span class="string">&#x27;httpbin.org&#x27;</span>, path=<span class="string">&#x27;/elsewhere&#x27;</span>)</span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/cookies&#x27;</span></span><br><span class="line">r = requests.get(url, cookies=jar)</span><br><span class="line">r.text</span><br></pre></td></tr></table></figure>


<h4 id="重定向与请求历史"><a href="#重定向与请求历史" class="headerlink" title="重定向与请求历史"></a>重定向与请求历史</h4><p>Response.history 是一个 Response 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">&#x27;http://github.com&#x27;</span>)</span><br><span class="line">r.url</span><br><span class="line"><span class="string">&#x27;https://github.com/&#x27;</span></span><br><span class="line">r.status_code</span><br><span class="line"><span class="number">200</span></span><br><span class="line">r.history</span><br><span class="line">[&lt;Response [<span class="number">301</span>]&gt;]</span><br></pre></td></tr></table></figure>


<h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>你可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">requests.get(<span class="string">&#x27;http://github.com&#x27;</span>, timeout=<span class="number">0.001</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">requests.exceptions.Timeout: HTTPConnectionPool(host=<span class="string">&#x27;github.com&#x27;</span>, port=<span class="number">80</span>): Request timed out. (timeout=<span class="number">0.001</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意 : timeout 仅对连接过程有效，与响应体的下载无关。 timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do not time out.</p>
<h4 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h4><p>遇到网络问题（如：DNS 查询失败、拒绝连接等）时，Requests 会抛出一个 ConnectionError 异常。<br>如果 HTTP 请求返回了不成功的状态码， Response.raise_for_status() 会抛出一个 HTTPError 异常。<br>若请求超时，则抛出一个 Timeout 异常。<br>若请求超过了设定的最大重定向次数，则会抛出一个 TooManyRedirects 异常。<br>所有Requests显式抛出的异常都继承自 requests.exceptions.RequestException 。</p>
<h4 id="会话对象"><a href="#会话对象" class="headerlink" title="会话对象"></a>会话对象</h4><p>会话对象让你能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookie， 期间使用 urllib3 的 connection pooling 功能。所以如果你向同一主机发送多个请求，底层的 TCP 连接将会被重用，从而带来显著的性能提升。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">&#x27;http://httpbin.org/cookies/set/sessioncookie/123456789&#x27;</span>)</span><br><span class="line">r = s.get(<span class="string">&quot;http://httpbin.org/cookies&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="comment"># &#x27;&#123;&quot;cookies&quot;: &#123;&quot;sessioncookie&quot;: &quot;123456789&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">r = s.get(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>, cookies=&#123;<span class="string">&#x27;from-my&#x27;</span>: <span class="string">&#x27;browser&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="comment"># &#x27;&#123;&quot;cookies&quot;: &#123;&quot;from-my&quot;: &quot;browser&quot;&#125;&#125;&#x27;</span></span><br><span class="line">r = s.get(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="comment"># &#x27;&#123;&quot;cookies&quot;: &#123;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>前后文管理器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> requests.Session() <span class="keyword">as</span> s:</span><br><span class="line">    s.get(<span class="string">&#x27;http://httpbin.org/cookies/set/sessioncookie/123456789&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="请求头与响应头"><a href="#请求头与响应头" class="headerlink" title="请求头与响应头"></a>请求头与响应头</h4><p>服务器返回给我们的响应头部信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r.headers</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;content-length&#x27;</span>: <span class="string">&#x27;56170&#x27;</span>, <span class="string">&#x27;x-content-type-options&#x27;</span>: <span class="string">&#x27;nosniff&#x27;</span>, <span class="string">&#x27;x-cache&#x27;</span>:</span><br><span class="line"><span class="string">&#x27;HIT from cp1006.eqiad.wmnet, MISS from cp1010.eqiad.wmnet&#x27;</span>, <span class="string">&#x27;content-encoding&#x27;</span>:</span><br><span class="line"><span class="string">&#x27;gzip&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;3080&#x27;</span>, <span class="string">&#x27;content-language&#x27;</span>: <span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;vary&#x27;</span>: <span class="string">&#x27;Accept-Encoding,Cookie&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;server&#x27;</span>: <span class="string">&#x27;Apache&#x27;</span>, <span class="string">&#x27;last-modified&#x27;</span>: <span class="string">&#x27;Wed, 13 Jun 2012 01:33:50 GMT&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;connection&#x27;</span>: <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;cache-control&#x27;</span>: <span class="string">&#x27;private, s-maxage=0, max-age=0,</span></span><br><span class="line"><span class="string">must-revalidate&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;Thu, 14 Jun 2012 12:59:39 GMT&#x27;</span>, <span class="string">&#x27;content-type&#x27;</span>:</span><br><span class="line"><span class="string">&#x27;text/html; charset=UTF-8&#x27;</span>, <span class="string">&#x27;x-cache-lookup&#x27;</span>: <span class="string">&#x27;HIT from cp1006.eqiad.wmnet:3128,</span></span><br><span class="line"><span class="string">MISS from cp1010.eqiad.wmnet:80&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>发送到服务器的请求的头部</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.request.headers</span><br><span class="line">&#123;<span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;identity, deflate, compress, gzip&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;*/*&#x27;</span>, <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;python-requests/0.13.1&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="准备的请求-（Prepared-Request）"><a href="#准备的请求-（Prepared-Request）" class="headerlink" title="准备的请求 （Prepared Request）"></a>准备的请求 （Prepared Request）</h4><p>当你从 API 或者会话调用中收到一个 Response 对象时，request 属性其实是使用了 PreparedRequest。有时在发送请求之前，你需要对 body 或者 header （或者别的什么东西）做一些额外处理，下面演示了一个简单的做法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line"></span><br><span class="line">s = Session()</span><br><span class="line">req = Request(<span class="string">&#x27;GET&#x27;</span>, url,</span><br><span class="line">    data=data,</span><br><span class="line">    headers=header</span><br><span class="line">)</span><br><span class="line">prepped = req.prepare()</span><br><span class="line"></span><br><span class="line"><span class="comment"># do something with prepped.body</span></span><br><span class="line"><span class="comment"># do something with prepped.headers</span></span><br><span class="line"></span><br><span class="line">resp = s.send(prepped,</span><br><span class="line">    stream=stream,</span><br><span class="line">    verify=verify,</span><br><span class="line">    proxies=proxies,</span><br><span class="line">    cert=cert,</span><br><span class="line">    timeout=timeout</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resp.status_code)</span><br></pre></td></tr></table></figure>
<p>由于你没有对 Request 对象做什么特殊事情，你立即准备和修改了 PreparedRequest 对象，然后把它和别的参数一起发送到 requests.* 或者 Session.*。</p>
<p>然而，上述代码会失去 Requests Session 对象的一些优势， 尤其 Session 级别的状态，例如 cookie 就不会被应用到你的请求上去。要获取一个带有状态的 PreparedRequest， 请用 Session.prepare_request() 取代 Request.prepare() 的调用，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line"></span><br><span class="line">s = Session()</span><br><span class="line">req = Request(<span class="string">&#x27;GET&#x27;</span>,  url,</span><br><span class="line">    data=data</span><br><span class="line">    headers=headers</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">prepped = s.prepare_request(req)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do something with prepped.body</span></span><br><span class="line"><span class="comment"># do something with prepped.headers</span></span><br><span class="line"></span><br><span class="line">resp = s.send(prepped,</span><br><span class="line">    stream=stream,</span><br><span class="line">    verify=verify,</span><br><span class="line">    proxies=proxies,</span><br><span class="line">    cert=cert,</span><br><span class="line">    timeout=timeout</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resp.status_code)</span><br></pre></td></tr></table></figure>
<h4 id="SSL-证书验证"><a href="#SSL-证书验证" class="headerlink" title="SSL 证书验证"></a>SSL 证书验证</h4><p>Requests 可以为 HTTPS 请求验证 SSL 证书，就像 web 浏览器一样。SSL 验证默认是开启的，如果证书验证失败，Requests 会抛出 SSLError:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">requests.get(&#x27;https://requestb.in&#x27;)</span><br><span class="line">requests.exceptions.SSLError: hostname &#x27;requestb.in&#x27; doesn&#x27;t match either of &#x27;*.herokuapp.com&#x27;, &#x27;herokuapp.com&#x27;</span><br></pre></td></tr></table></figure>
<p>在该域名上我没有设置 SSL，所以失败了。但 Github 设置了 SSL:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">requests.get(&#x27;https://github.com&#x27;, verify=True)</span><br><span class="line">&lt;Response [200]&gt;</span><br></pre></td></tr></table></figure>
<p>你可以为 verify 传入 CA_BUNDLE 文件的路径，或者包含可信任 CA 证书文件的文件夹路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(&#x27;https://github.com&#x27;, verify=&#x27;/path/to/certfile&#x27;)</span><br></pre></td></tr></table></figure>
<p>或者将其保持在会话中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.verify = &#x27;/path/to/certfile&#x27;</span><br></pre></td></tr></table></figure>
<p>注解<br>如果 verify 设为文件夹路径，文件夹必须通过 OpenSSL 提供的 c_rehash 工具处理。</p>
<p>你还可以通过 REQUESTS_CA_BUNDLE 环境变量定义可信任 CA 列表。</p>
<p>如果你将 verify 设置为 False，Requests 也能忽略对 SSL 证书的验证。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> requests.get(&#x27;https://kennethreitz.org&#x27;, verify=False)</span><br><span class="line">&lt;Response [200]&gt;</span><br></pre></td></tr></table></figure>
<p>默认情况下， verify 是设置为 True 的。选项 verify 仅应用于主机证书。<br>对于私有证书，你也可以传递一个 CA_BUNDLE 文件的路径给 verify。你也可以设置 # REQUEST_CA_BUNDLE 环境变量。</p>
<h4 id="客户端证书"><a href="#客户端证书" class="headerlink" title="客户端证书"></a>客户端证书</h4><p>你也可以指定一个本地证书用作客户端证书，可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> requests.get(&#x27;https://kennethreitz.org&#x27;, cert=(&#x27;/path/client.cert&#x27;, &#x27;/path/client.key&#x27;))</span><br><span class="line">&lt;Response [200]&gt;</span><br></pre></td></tr></table></figure>
<p>或者保持在会话中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.cert = <span class="string">&#x27;/path/client.cert&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果你指定了一个错误路径或一个无效的证书:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> requests.get(<span class="string">&#x27;https://kennethreitz.org&#x27;</span>, cert=<span class="string">&#x27;/wrong_path/client.pem&#x27;</span>)</span><br><span class="line">SSLError: [Errno <span class="number">336265225</span>] _ssl.c:<span class="number">347</span>: error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib</span><br></pre></td></tr></table></figure>
<p>警告 ：本地证书的私有 key 必须是解密状态。目前，Requests 不支持使用加密的 k</p>
<h4 id="响应体内容工作流"><a href="#响应体内容工作流" class="headerlink" title="响应体内容工作流"></a>响应体内容工作流</h4><p>默认情况下，当你进行网络请求后，响应体会立即被下载。你可以通过 stream 参数覆盖这个行为，推迟下载响应体直到访问 Response.content 属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tarball_url = <span class="string">&#x27;https://github.com/kennethreitz/requests/tarball/master&#x27;</span></span><br><span class="line">r = requests.get(tarball_url, stream=<span class="literal">True</span>)</span><br><span class="line">此时仅有响应头被下载下来了，连接保持打开状态，因此允许我们根据条件获取内容：</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(r.headers[<span class="string">&#x27;content-length&#x27;</span>]) &lt; TOO_LONG:</span><br><span class="line">  content = r.content</span><br><span class="line">  ...</span><br><span class="line">你可以进一步使用 Response.iter_content 和 Response.iter_lines 方法来控制工作流，或者以 Response.raw 从底层 urllib3 的 urllib3.HTTPResponse &lt;urllib3.response.HTTPResponse 读取未解码的响应体。</span><br><span class="line"></span><br><span class="line">如果你在请求中把 stream 设为 <span class="literal">True</span>，Requests 无法将连接释放回连接池，除非你 消耗了所有的数据，或者调用了 Response.close。 这样会带来连接效率低下的问题。如果你发现你在使用 stream=<span class="literal">True</span> 的同时还在部分读取请求的 body（或者完全没有读取 body），那么你就应该考虑使用 <span class="keyword">with</span> 语句发送请求，这样可以保证请求一定会被关闭：</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>, stream=<span class="literal">True</span>) <span class="keyword">as</span> r:</span><br><span class="line">    <span class="comment"># 在此处理响应。</span></span><br></pre></td></tr></table></figure>
<h4 id="流式上传"><a href="#流式上传" class="headerlink" title="流式上传"></a>流式上传</h4><p>Requests支持流式上传，这允许你发送大的数据流或文件而无需先把它们读入内存。要使用流式上传，仅需为你的请求体提供一个类文件对象即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;massive-body&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    requests.post(<span class="string">&#x27;http://some.url/streamed&#x27;</span>, data=f)</span><br></pre></td></tr></table></figure>
<p>警告 ：我们强烈建议你用二进制模式（binary mode）打开文件。这是因为 requests 可能会为你提供 header 中的 Content-Length，在这种情况下该值会被设为文件的字节数。如果你用文本模式打开文件，就可能碰到错误。</p>
<h4 id="块编码请求"><a href="#块编码请求" class="headerlink" title="块编码请求"></a>块编码请求</h4><p>对于出去和进来的请求，Requests 也支持分块传输编码。要发送一个块编码的请求，仅需为你的请求体提供一个生成器（或任意没有具体长度的迭代器）：</p>
<p>对于分块的编码请求，我们最好使用 Response.iter_content() 对其数据进行迭代。在理想情况下，你的 request 会设置 stream&#x3D;True，这样你就可以通过调用 iter_content 并将分块大小参数设为 None，从而进行分块的迭代。如果你要设置分块的最大体积，你可以把分块大小参数设为任意整数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;there&#x27;</span></span><br><span class="line"></span><br><span class="line">requests.post(<span class="string">&#x27;http://some.url/chunked&#x27;</span>, data=gen())</span><br></pre></td></tr></table></figure>
<h4 id="POST-多个分块编码的文件"><a href="#POST-多个分块编码的文件" class="headerlink" title="POST 多个分块编码的文件"></a>POST 多个分块编码的文件</h4><p>你可以在一个请求中发送多个文件。例如，假设你要上传多个图像文件到一个 HTML 表单，使用一个多文件 field 叫做 “images”:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;images&quot;</span> <span class="attr">multiple</span>=<span class="string">&quot;true&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>要实现，只要把文件设到一个元组的列表中，其中元组结构为 (form_field_name, file_info):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line"> multiple_files = [</span><br><span class="line">        (<span class="string">&#x27;images&#x27;</span>, (<span class="string">&#x27;foo.png&#x27;</span>, <span class="built_in">open</span>(<span class="string">&#x27;foo.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>), <span class="string">&#x27;image/png&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;images&#x27;</span>, (<span class="string">&#x27;bar.png&#x27;</span>, <span class="built_in">open</span>(<span class="string">&#x27;bar.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>), <span class="string">&#x27;image/png&#x27;</span>))]</span><br><span class="line"> r = requests.post(url, files=multiple_files)</span><br><span class="line"> r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&#x27;files&#x27;</span>: &#123;<span class="string">&#x27;images&#x27;</span>: <span class="string">&#x27;data:image/png;base64,iVBORw ....&#x27;</span>&#125;</span><br><span class="line">  <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>警告 ：我们强烈建议你用二进制模式（binary mode）打开文件。这是因为 requests 可能会为你提供 header 中的 Content-Length，在这种情况下该值会被设为文件的字节数。如果你用文本模式打开文件，就可能碰到错误。</p>
<h4 id="事件挂钩"><a href="#事件挂钩" class="headerlink" title="事件挂钩"></a>事件挂钩</h4><p>Requests有一个钩子系统，你可以用来操控部分请求过程，或信号事件处理。</p>
<p>可用的钩子:</p>
<p>response:<br>从一个请求产生的响应<br>你可以通过传递一个 {hook_name: callback_function} 字典给 hooks 请求参数为每个请求分配一个钩子函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hooks=dict(response=print_url)</span><br></pre></td></tr></table></figure>
<p>callback_function 会接受一个数据块作为它的第一个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def print_url(r, *args, **kwargs):</span><br><span class="line">    print(r.url)</span><br></pre></td></tr></table></figure>
<p>若执行你的回调函数期间发生错误，系统会给出一个警告。</p>
<p>若回调函数返回一个值，默认以该值替换传进来的数据。若函数未返回任何东西，也没有什么其他的影响。</p>
<p>我们来在运行期间打印一些请求方法的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> requests.get(&#x27;http://httpbin.org&#x27;, hooks=dict(response=print_url))</span><br><span class="line">http://httpbin.org</span><br><span class="line">&lt;Response [200]&gt;</span><br></pre></td></tr></table></figure>
<h4 id="自定义身份验证"><a href="#自定义身份验证" class="headerlink" title="自定义身份验证"></a>自定义身份验证</h4><p>Requests 允许你使用自己指定的身份验证机制。</p>
<p>任何传递给请求方法的 auth 参数的可调用对象，在请求发出之前都有机会修改请求。</p>
<p>自定义的身份验证机制是作为 requests.auth.AuthBase 的子类来实现的，也非常容易定义。Requests 在 requests.auth 中提供了两种常见的的身份验证方案： HTTPBasicAuth 和 HTTPDigestAuth 。</p>
<p>假设我们有一个web服务，仅在 X-Pizza 头被设置为一个密码值的情况下才会有响应。虽然这不太可能，但就以它为例好了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> AuthBase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaAuth</span>(<span class="title class_ inherited__">AuthBase</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Attaches HTTP Pizza Authentication to the given Request object.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, username</span>):</span><br><span class="line">        <span class="comment"># setup any auth-related data here</span></span><br><span class="line">        self.username = username</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, r</span>):</span><br><span class="line">        <span class="comment"># modify and return the request</span></span><br><span class="line">        r.headers[<span class="string">&#x27;X-Pizza&#x27;</span>] = self.username</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>然后就可以使用我们的PizzaAuth来进行网络请求:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> requests.get(<span class="string">&#x27;http://pizzabin.org/admin&#x27;</span>, auth=PizzaAuth(<span class="string">&#x27;kenneth&#x27;</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>
<h4 id="流式请求"><a href="#流式请求" class="headerlink" title="流式请求"></a>流式请求</h4><p>使用 Response.iter_lines() 你可以很方便地对流式 API （例如 Twitter 的流式 API ） 进行迭代。简单地设置 stream 为 True 便可以使用 iter_lines 对相应进行迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;http://httpbin.org/stream/20&#x27;</span>, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> r.iter_lines():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># filter out keep-alive new lines</span></span><br><span class="line">    <span class="keyword">if</span> line:</span><br><span class="line">        decoded_line = line.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(json.loads(decoded_line))</span><br></pre></td></tr></table></figure>
<p>当使用 decode_unicode&#x3D;True 在 Response.iter_lines() 或 Response.iter_content() 中时，你需要提供一个回退编码方式，以防服务器没有提供默认回退编码，从而导致错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">&#x27;http://httpbin.org/stream/20&#x27;</span>, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r.encoding <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    r.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> r.iter_lines(decode_unicode=<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">if</span> line:</span><br><span class="line">        <span class="built_in">print</span>(json.loads(line))</span><br></pre></td></tr></table></figure>
<p>警告</p>
<p>iter_lines 不保证重进入时的安全性。多次调用该方法 会导致部分收到的数据丢失。如果你要在多处调用它，就应该使用生成的迭代器对象:</p>
<p>lines &#x3D; r.iter_lines()<br>保存第一行以供后面使用，或者直接跳过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first_line = next(lines)</span><br><span class="line"></span><br><span class="line">for line in lines:</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>如果需要使用代理，你可以通过为任意请求方法提供 proxies 参数来配置单个请求:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">  <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://10.10.1.10:3128&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https&quot;</span>: <span class="string">&quot;http://10.10.1.10:1080&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requests.get(<span class="string">&quot;http://example.org&quot;</span>, proxies=proxies)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你也可以通过环境变量 HTTP_PROXY 和 HTTPS_PROXY 来配置代理。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> HTTP_PROXY=<span class="string">&quot;http://10.10.1.10:3128&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> HTTPS_PROXY=<span class="string">&quot;http://10.10.1.10:1080&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python</span></span><br><span class="line"> import requests</span><br><span class="line"> requests.get(&quot;http://example.org&quot;)</span><br></pre></td></tr></table></figure>
<p>若你的代理需要使用HTTP Basic Auth，可以使用 <a target="_blank" rel="noopener" href="http://user:password@host/">http://user:password@host/</a> 语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://user:pass@10.10.1.10:3128/&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要为某个特定的连接方式或者主机设置代理，使用 scheme:&#x2F;&#x2F;hostname 作为 key， 它会针对指定的主机和连接方式进行匹配。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxies = &#123;<span class="string">&#x27;http://10.20.1.128&#x27;</span>: <span class="string">&#x27;http://10.10.1.10:5323&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>注意，代理 URL 必须包含连接方式。</p>
<h4 id="SOCKS"><a href="#SOCKS" class="headerlink" title="SOCKS"></a>SOCKS</h4><p>除了基本的 HTTP 代理，Request 还支持 SOCKS 协议的代理。这是一个可选功能，若要使用， 你需要安装第三方库。</p>
<p>你可以用 pip 获取依赖:</p>
<h4 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h4><p>Requests 提供了几乎所有HTTP动词的功能：GET、OPTIONS、HEAD、POST、PUT、PATCH、DELETE</p>
<h4 id="定制动词"><a href="#定制动词" class="headerlink" title="定制动词"></a>定制动词</h4><p>有时候你会碰到一些服务器，处于某些原因，它们允许或者要求用户使用上述 HTTP 动词之外的定制动词。比如说 WEBDAV 服务器会要求你使用 MKCOL 方法。别担心，Requests 一样可以搞定它们。你可以使用内建的 .request 方法，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> r = requests.request(<span class="string">&#x27;MKCOL&#x27;</span>, url, data=data)</span><br><span class="line"> r.status_code</span><br><span class="line"><span class="number">200</span> <span class="comment"># Assuming your call was correct</span></span><br></pre></td></tr></table></figure>
<p>这样你就可以使用服务器要求的任意方法动词了。</p>
<h4 id="响应头链接字段"><a href="#响应头链接字段" class="headerlink" title="响应头链接字段"></a>响应头链接字段</h4><p>许多 HTTP API 都有响应头链接字段的特性，它们使得 API 能够更好地自我描述和自我显露。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> url = <span class="string">&#x27;https://api.github.com/users/kennethreitz/repos?page=1&amp;per_page=10&#x27;</span></span><br><span class="line"> r = requests.head(url=url)</span><br><span class="line"> r.headers[<span class="string">&#x27;link&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&lt;https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10&gt;; rel=&quot;next&quot;, &lt;https://api.github.com/users/kennethreitz/repos?page=6&amp;per_page=10&gt;; rel=&quot;last&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Requests 会自动解析这些响应头链接字段，并使得它们非常易于使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> r.links[<span class="string">&quot;next&quot;</span>]</span><br><span class="line">&#123;<span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10&#x27;</span>, <span class="string">&#x27;rel&#x27;</span>: <span class="string">&#x27;next&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"> r.links[<span class="string">&quot;last&quot;</span>]</span><br><span class="line">&#123;<span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.com/users/kennethreitz/repos?page=7&amp;per_page=10&#x27;</span>, <span class="string">&#x27;rel&#x27;</span>: <span class="string">&#x27;last&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="传输适配器"><a href="#传输适配器" class="headerlink" title="传输适配器"></a>传输适配器</h4><p>传输适配器提供了一个机制，让你可以为 HTTP 服务定义交互方法。尤其是它允许你应用服务前的配置。</p>
<p>Requests 自带了一个传输适配器，也就是 HTTPAdapter。 这个适配器使用了强大的 urllib3，为 Requests 提供了默认的 HTTP 和 HTTPS 交互。每当 Session 被初始化，就会有适配器附着在 Session 上，其中一个供 HTTP 使用，另一个供 HTTPS 使用。</p>
<p>Request 允许用户创建和使用他们自己的传输适配器，实现他们需要的特殊功能。创建好以后，传输适配器可以被加载到一个会话对象上，附带着一个说明，告诉会话适配器应该应用在哪个 web 服务上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.mount(<span class="string">&#x27;http://www.github.com&#x27;</span>, MyAdapter())</span><br></pre></td></tr></table></figure>
<p>这个 mount 调用会注册一个传输适配器的特定实例到一个前缀上面。加载以后，任何使用该会话的 HTTP 请求，只要其 URL 是以给定的前缀开头，该传输适配器就会被使用到。</p>
<p>传输适配器的众多实现细节不在本文档的覆盖范围内，不过你可以看看接下来这个简单的 SSL 用例。更多的用法，你也许该考虑为 BaseAdapter 创建子类</p>
<h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><p>使用默认的传输适配器，Requests 不提供任何形式的非阻塞 IO。 Response.content 属性会阻塞，直到整个响应下载完成。如果你需要更多精细控制，该库的数据流功能（见 流式请求） 允许你每次接受少量的一部分响应，不过这些调用依然是阻塞式的。</p>
<p>如果你对于阻塞式 IO 有所顾虑，还有很多项目可以供你使用，它们结合了 Requests 和 Python 的某个异步框架。典型的优秀例子是 grequests 和 requests-futures。</p>
<h4 id="Header-排序"><a href="#Header-排序" class="headerlink" title="Header 排序"></a>Header 排序</h4><p>在某些特殊情况下你也许需要按照次序来提供 header，如果你向 headers 关键字参数传入一个 OrderedDict，就可以向提供一个带排序的 header。然而，Requests 使用的默认 header 的次序会被优先选择，这意味着如果你在 headers 关键字参数中覆盖了默认 header，和关键字参数中别的 header 相比，它们也许看上去会是次序错误的。</p>
<p>如果这个对你来说是个问题，那么用户应该考虑在 Session 对象上面设置默认 header，只要将 Session 设为一个定制的 OrderedDict 即可。这样就会让它成为优选的次序。</p>
<h4 id="超时（timeout）"><a href="#超时（timeout）" class="headerlink" title="超时（timeout）"></a>超时（timeout）</h4><p>如果你制订了一个单一的值作为 timeout，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(&#x27;https://github.com&#x27;, timeout=5)</span><br></pre></td></tr></table></figure>
<p>这一 timeout 值将会用作 connect 和 read 二者的 timeout。如果要分别制定，就传入一个元组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(&#x27;https://github.com&#x27;, timeout=(3.05, 27))</span><br></pre></td></tr></table></figure>
<p>如果远端服务器很慢，你可以让 Request 永远等待，传入一个 None 作为 timeout 值，然后就冲咖啡去吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(&#x27;https://github.com&#x27;, timeout=None)</span><br></pre></td></tr></table></figure>

<h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><h4 id="基本身份认证"><a href="#基本身份认证" class="headerlink" title="基本身份认证"></a>基本身份认证</h4><p>许多要求身份认证的web服务都接受 HTTP Basic Auth。这是最简单的一种身份认证，并且 Requests 对这种认证方式的支持是直接开箱即可用。</p>
<p>以 HTTP Basic Auth 发送请求非常简单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> from requests.auth import HTTPBasicAuth</span><br><span class="line"> requests.get(&#x27;https://api.github.com/user&#x27;, auth=HTTPBasicAuth(&#x27;user&#x27;, &#x27;pass&#x27;))</span><br><span class="line">&lt;Response [200]&gt;</span><br></pre></td></tr></table></figure>
<p>事实上，HTTP Basic Auth 如此常见，Requests 就提供了一种简写的使用方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> requests.get(&#x27;https://api.github.com/user&#x27;, auth=(&#x27;user&#x27;, &#x27;pass&#x27;))</span><br><span class="line">&lt;Response [200]&gt;</span><br></pre></td></tr></table></figure>
<p>像这样在一个元组中提供认证信息与前一个 HTTPBasicAuth 例子是完全相同的。</p>
<h4 id="netrc-认证"><a href="#netrc-认证" class="headerlink" title="netrc 认证"></a>netrc 认证</h4><p>如果认证方法没有收到 auth 参数，Requests 将试图从用户的 netrc 文件中获取 URL 的 hostname 需要的认证身份。The netrc file overrides raw HTTP authentication headers set with headers&#x3D;.</p>
<p>如果找到了 hostname 对应的身份，就会以 HTTP Basic Auth 的形式发送请求。</p>
<h4 id="摘要式身份认证"><a href="#摘要式身份认证" class="headerlink" title="摘要式身份认证"></a>摘要式身份认证</h4><p>另一种非常流行的 HTTP 身份认证形式是摘要式身份认证，Requests 对它的支持也是开箱即可用的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPDigestAuth</span><br><span class="line"> url = <span class="string">&#x27;http://httpbin.org/digest-auth/auth/user/pass&#x27;</span></span><br><span class="line"> requests.get(url, auth=HTTPDigestAuth(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>
<h4 id="OAuth-1-认证"><a href="#OAuth-1-认证" class="headerlink" title="OAuth 1 认证"></a>OAuth 1 认证</h4><p>Oauth 是一种常见的 Web API 认证方式。 requests-oauthlib 库可以让 Requests 用户简单地创建 OAuth 认证的请求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> requests</span><br><span class="line"> <span class="keyword">from</span> requests_oauthlib <span class="keyword">import</span> OAuth1</span><br><span class="line"> url = <span class="string">&#x27;https://api.twitter.com/1.1/account/verify_credentials.json&#x27;</span></span><br><span class="line"> auth = OAuth1(<span class="string">&#x27;YOUR_APP_KEY&#x27;</span>, <span class="string">&#x27;YOUR_APP_SECRET&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>              <span class="string">&#x27;USER_OAUTH_TOKEN&#x27;</span>, <span class="string">&#x27;USER_OAUTH_TOKEN_SECRET&#x27;</span>)</span><br><span class="line"> requests.get(url, auth=auth)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>
<h4 id="新的身份认证形式"><a href="#新的身份认证形式" class="headerlink" title="新的身份认证形式"></a>新的身份认证形式</h4><p>如果你找不到所需要的身份认证形式的一个良好实现，你也可以自己实现它。Requests 非常易于添加你自己的身份认证形式。</p>
<p>要想自己实现，就从 AuthBase 继承一个子类，并实现 <strong>call</strong>() 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> requests</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">MyAuth</span>(requests.auth.AuthBase):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, r</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># Implement my authentication</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> r</span><br><span class="line">...</span><br><span class="line"> url = <span class="string">&#x27;http://httpbin.org/get&#x27;</span></span><br><span class="line"> requests.get(url, auth=MyAuth())</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>
<p>当一个身份认证模块被附加到一个请求上，在设置 request 期间就会调用该模块。因此 <strong>call</strong> 方法必须完成使得身份认证生效的所有事情。一些身份认证形式会额外地添加钩子来提供进一步的功能。</p>
<h4 id="json-content-与-text-区别"><a href="#json-content-与-text-区别" class="headerlink" title="json content 与 text 区别"></a>json content 与 text 区别</h4><p>json() 必须加括号<br>text 代表返回的数据是文字<br>content 代表返回的数据是多媒体，图片，音乐，视频</p>

        
            <div id="toc-article">
                
  <div class="widget-wrap" id="toc-wrap">
    <h3 class="widget-title"><i class="fa fa-toc"></i> 文章目录</h3>
    <div class="widget">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-text">用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%86%85%E5%AE%B9"><span class="toc-text">响应内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-text">编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%93%8D%E5%BA%94%E5%86%85%E5%AE%B9"><span class="toc-text">二进制响应内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON-%E5%93%8D%E5%BA%94%E5%86%85%E5%AE%B9"><span class="toc-text">JSON 响应内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%93%8D%E5%BA%94%E5%86%85%E5%AE%B9"><span class="toc-text">原始响应内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">定制请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POST%E4%B8%80%E4%B8%AA%E5%A4%9A%E9%83%A8%E5%88%86%E7%BC%96%E7%A0%81-Multipart-Encoded-%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-text">POST一个多部分编码(Multipart-Encoded)的文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">响应状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">响应头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie"><span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%8E%86%E5%8F%B2"><span class="toc-text">重定向与请求历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6"><span class="toc-text">超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-text">错误与异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%AF%B9%E8%B1%A1"><span class="toc-text">会话对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">请求头与响应头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E7%9A%84%E8%AF%B7%E6%B1%82-%EF%BC%88Prepared-Request%EF%BC%89"><span class="toc-text">准备的请求 （Prepared Request）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSL-%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81"><span class="toc-text">SSL 证书验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%81%E4%B9%A6"><span class="toc-text">客户端证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E4%BD%93%E5%86%85%E5%AE%B9%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-text">响应体内容工作流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E4%B8%8A%E4%BC%A0"><span class="toc-text">流式上传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E7%BC%96%E7%A0%81%E8%AF%B7%E6%B1%82"><span class="toc-text">块编码请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POST-%E5%A4%9A%E4%B8%AA%E5%88%86%E5%9D%97%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-text">POST 多个分块编码的文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8C%82%E9%92%A9"><span class="toc-text">事件挂钩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="toc-text">自定义身份验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E8%AF%B7%E6%B1%82"><span class="toc-text">流式请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-text">代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SOCKS"><span class="toc-text">SOCKS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%8A%A8%E8%AF%8D"><span class="toc-text">HTTP动词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E5%8A%A8%E8%AF%8D"><span class="toc-text">定制动词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%B4%E9%93%BE%E6%8E%A5%E5%AD%97%E6%AE%B5"><span class="toc-text">响应头链接字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">传输适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞和非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Header-%E6%8E%92%E5%BA%8F"><span class="toc-text">Header 排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%EF%BC%88timeout%EF%BC%89"><span class="toc-text">超时（timeout）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-text">身份认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-text">基本身份认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netrc-%E8%AE%A4%E8%AF%81"><span class="toc-text">netrc 认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%98%E8%A6%81%E5%BC%8F%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-text">摘要式身份认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OAuth-1-%E8%AE%A4%E8%AF%81"><span class="toc-text">OAuth 1 认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%BD%A2%E5%BC%8F"><span class="toc-text">新的身份认证形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#json-content-%E4%B8%8E-text-%E5%8C%BA%E5%88%AB"><span class="toc-text">json content 与 text 区别</span></a></li></ol></li></ol>
    </div>
  </div>


            </div>
        
<!--          -->
<!--           <blockquote id="copyright"> -->
<!--               <p>原文链接: <a href="https://dbbruce.github.io/2023/08/11/爬虫/基础/003-requests相关知识/">https://dbbruce.github.io/2023/08/11/爬虫/基础/003-requests相关知识/</a></p> -->
<!--               <p>版权声明: 转载请注明出处.</p> -->
<!--           </blockquote> -->
<!--          -->
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          <!--  -->
<!--     <div class="social-share"> -->
<!--       <span>分享到:</span> -->
<!--     </div> -->
<!--  -->
<!--  -->

        </div>
      
      
        
<nav id="article-nav">
  
    <a href="/2023/08/11/%E7%BD%91%E7%BB%9C/100%20%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%8C%E7%9C%8B%E5%AE%8C%E6%88%90%E5%8D%8A%E4%B8%AA%E7%BD%91%E7%BB%9C%E9%AB%98%E6%89%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          100个网络基础知识，看完成半个网络高手
        
      </div>
    </a>
  
  
    <a href="/2023/08/11/python/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/yield%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          yield实现协程
        
      </div>
    </a>
  
</nav>

      
      
        








      
    </footer>
  </div>
</article>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> 最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/23/%E9%A1%B9%E7%9B%AE/HCM%E6%95%99%E7%A8%8B/054-%E7%BB%84%E7%BB%87%E4%BA%BA%E4%BA%8B%E7%AC%94%E8%AE%B0/">054-组织人事笔记</a>
          </li>
        
          <li>
            <a href="/2025/06/21/%E9%A1%B9%E7%9B%AE/HCM%E6%95%99%E7%A8%8B/053-perf.assess.card.new.finalized%E7%9A%84post%E6%8F%92%E4%BB%B6/">053-perf.assess.card.new.finalized的post插件</a>
          </li>
        
          <li>
            <a href="/2025/06/20/%E9%A1%B9%E7%9B%AE/HCM%E6%95%99%E7%A8%8B/052-%E4%BA%91%E5%87%BD%E6%95%B0%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8/">052-云函数互相调用</a>
          </li>
        
          <li>
            <a href="/2025/06/08/%E9%A1%B9%E7%9B%AE/HCM%E6%95%99%E7%A8%8B/051-%E5%B8%B8%E7%94%A8relation%E9%85%8D%E7%BD%AE/">051-常用relation配置</a>
          </li>
        
          <li>
            <a href="/2025/06/07/%E9%A1%B9%E7%9B%AE/HCM%E6%95%99%E7%A8%8B/050-%E6%B5%81%E7%A8%8B%E4%B8%AD%E8%B7%B3%E8%BD%AC%E5%88%AB%E7%9A%84%E6%B5%81%E7%A8%8B/">050-流程中跳转别的流程</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> 分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO%E8%AF%AD%E8%A8%80/">GO语言</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/GO%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%80/">Python基础</a><span class="category-list-count">21</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%80/Django/">Django</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%80/%E5%8C%85%E6%96%B9%E6%B3%95/">包方法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程</a><span class="category-list-count">12</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/git/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/odoo/">odoo</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/odoo/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">11</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%8F%E6%9C%88%E6%A6%82%E8%A6%81/">每月概要</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%8F%E6%9C%88%E6%A6%82%E8%A6%81/2023/">2023</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%8F%E6%9C%88%E6%A6%82%E8%A6%81/2025/">2025</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB%E7%B1%BB/">爬虫类</a><span class="category-list-count">28</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB%E7%B1%BB/%E5%8F%8D%E7%88%AC/">反爬</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB%E7%B1%BB/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB%E7%B1%BB/%E7%BC%96%E7%A0%81/">编码</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/%E5%BC%82%E5%B8%B8/">异常</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a><span class="category-list-count">197</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/Git/">Git</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/Java%E7%94%9F%E6%80%81/">Java生态</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/K8S/">K8S</a><span class="category-list-count">48</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/K8S/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">45</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/K8S/%E9%94%99%E8%AF%AF/">错误</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/K8S/%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%80%BB/">项目汇总</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/docker/">docker</a><span class="category-list-count">22</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/docker/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/docker/%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/">错误集锦</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/grafana/">grafana</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/linux%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">linux云计算基础教程</a><span class="category-list-count">63</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/memcached/">memcached</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/nginx/">nginx</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/zabbix/">zabbix</a><span class="category-list-count">19</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/zabbix/5-0LTS/">5.0LTS</a><span class="category-list-count">19</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/">常用工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/">抓包工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%E5%92%8C%E5%B8%B8%E8%AF%86/">运维一些技巧和常识</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/">问题处理</a><span class="category-list-count">5</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E9%A2%98/">题</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><span class="category-list-count">80</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/HCM%E6%95%99%E7%A8%8B/">HCM教程</a><span class="category-list-count">55</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/%E5%8C%BB%E8%8D%AF%E5%85%AC%E5%8F%B8ERP/">医药公司ERP</a><span class="category-list-count">25</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/%E5%8C%BB%E8%8D%AF%E5%85%AC%E5%8F%B8ERP/%E4%B8%9A%E5%8A%A1/">业务</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/%E5%8C%BB%E8%8D%AF%E5%85%AC%E5%8F%B8ERP/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">3</span></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> 归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025年</a><span class="archive-list-count">59</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023年</a><span class="archive-list-count">135</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022年</a><span class="archive-list-count">40</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021年</a><span class="archive-list-count">107</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020年</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018年</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2000/">2000年</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> 友情链接</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a href="https://dbbruce.github.io/">董迟钝的Blog</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
<!--       <p> -->
<!--         <a href="/sitemap.xml">网站地图</a> -->
<!--         <span> | </span><a href="/atom.xml">订阅本站</a> -->
<!--         <span> | </span><a href="/about/">联系博主</a> -->
<!--       </p> -->
<!--        -->
<!--         <p> -->
<!--           <i class="fa fa-visitors"></i> -->
<!--           <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i> -->
<!--           ， -->
<!--           <i class="fa fa-views"></i> -->
<!--           <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i> -->
<!--         </p> -->
<!--        -->
<!--       <p> -->
        <span>Copyright &copy; 2025 DB Bruce. 董勉的技术博客  https://dbbruce.github.io</span>
<!--         <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span> -->
<!--         <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span> -->
<!--       </p> -->
    </div>
  </div>
</footer>

    </div>
  </div>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<!--  -->
<!--    -->
<!--     
<script src="/localshare/js/social-share.js"></script>
 -->
<!--     
<script src="/localshare/js/qrcode.js"></script>
 -->
<!--    -->
<!--    -->
<!--  -->


  

  

  

  

  

  

  

  
  





</body>
</html>